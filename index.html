<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048 — Vanilla JS</title>
  <meta name="description" content="Juego 2048 hecho en HTML, CSS y JS puro. Listo para GitHub Pages." />
  <!-- ADDED: color de barra del navegador en móvil -->
  <meta name="theme-color" content="#8f7a66" />
  <style>
    :root{
      --bg:#faf8ef;
      --board:#bbada0;
      --tile-empty:#cdc1b4;
      --text:#776e65;
      --text-light:#f9f6f2;
      --accent:#8f7a66;
      --btn:#8f7a66;
      --btn-hover:#7a6656;
      /* ADDED: safe areas */
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;display:flex;align-items:center;justify-content:center;
      background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      /* ADDED: evitar tirones y respetar notch */
      overscroll-behavior:none;
      padding-bottom:calc(12px + var(--safe-bottom));
      padding-top:var(--safe-top);
      touch-action:manipulation;
    }
    .wrap{width:min(95vw,560px);}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
    h1{font-size:42px;margin:0;color:var(--accent);letter-spacing:1px}
    .scores{display:flex;gap:10px}
    .badge{background:#bbada0;color:#fff;border-radius:10px;padding:8px 12px;min-width:90px;text-align:center}
    .badge .label{font-size:11px;opacity:.9}
    .badge .value{font-weight:800;font-size:18px}
    .controls{display:flex;gap:8px;margin:10px 0 8px;flex-wrap:wrap;align-items:center}
    .controls .right{margin-left:auto;display:flex;gap:8px;align-items:center}
    button{cursor:pointer;border:none;border-radius:10px;padding:10px 14px;background:var(--btn);color:white;font-weight:600}
    button:hover{background:var(--btn-hover)}
    .board{position:relative;background:var(--board);border-radius:14px;padding:10px;display:grid;grid-template-columns:repeat(4,1fr);grid-gap:10px;aspect-ratio:1/1;
      /* ADDED: mejorar gestos y evitar scroll mientras se desliza */
      touch-action:none;
    }
    .cell{background:var(--tile-empty);border-radius:10px}
    .tile{position:absolute;inset:auto;display:flex;align-items:center;justify-content:center;border-radius:10px;font-weight:800;font-size:28px;color:var(--text-light);
      width:calc((100% - 50px)/4);height:calc((100% - 50px)/4);transition:transform .12s ease-in, left .12s ease-in, top .12s ease-in;}
    .tile.new{animation:pop .12s ease-out}
    @keyframes pop{0%{transform:scale(.5)}100%{transform:scale(1)}}

    /* Colors per value */
    .v2{background:#eee4da;color:#776e65}
    .v4{background:#ede0c8;color:#776e65}
    .v8{background:#f2b179}
    .v16{background:#f59563}
    .v32{background:#f67c5f}
    .v64{background:#f65e3b}
    .v128{background:#edcf72;font-size:24px}
    .v256{background:#edcc61;font-size:24px}
    .v512{background:#edc850;font-size:24px}
    .v1024{background:#edc53f;font-size:20px}
    .v2048{background:#edc22e;font-size:20px}
    .v4096{background:#3c3a32}

    .msg{margin-top:12px;min-height:24px}
    .toast{background:#000000aa;color:#fff;position:fixed;left:50%;bottom:20px;transform:translateX(-50%);padding:10px 14px;border-radius:10px;font-size:14px;opacity:0;pointer-events:none;transition:opacity .2s}
    .toast.show{opacity:1}

    @media (max-width:380px){
      h1{font-size:34px}
      .badge{min-width:72px}
      .tile{font-size:22px}
      .v1024,.v2048{font-size:18px}
    }
    /* ADDED: estilo simple para el toggle */
    label.toggle{display:inline-flex;gap:6px;align-items:center;font-size:13px}
    label.toggle input{width:18px;height:18px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="badge"><div class="label">PUNTOS</div><div id="score" class="value">0</div></div>
        <div class="badge"><div class="label">RÉCORD</div><div id="best" class="value">0</div></div>
      </div>
    </header>
    <div class="controls">
      <button id="new">Nueva partida</button>
      <button id="undo" title="Deshacer último movimiento (1 paso)">Deshacer</button>
      <button id="help">Ayuda</button>
      <div class="right">
        <!-- ADDED: Vibración opcional y Pantalla completa -->
        <label class="toggle"><input type="checkbox" id="haptics" checked> Vibración</label>
        <button id="fs">Pantalla completa</button>
      </div>
    </div>

    <div class="board" id="board" aria-label="Tablero 2048" role="application">
      <!-- static background cells -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>
    <div class="msg" id="msg" aria-live="polite"></div>
  </div>
  <div class="toast" id="toast">Usa las flechas o desliza.</div>

  <script>
  // ---- 2048: lógica y UI en ~200 líneas ----
  const size = 4;
  const prob4 = 0.1; // 10% de probabilidad de sacar un 4
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const msgEl = document.getElementById('msg');
  const toast = document.getElementById('toast');
  // ADDED: referencias para vibración y fullscreen
  const hapticsEl = document.getElementById('haptics');

  let grid, score, best, tiles = new Map();
  let history = [];// para deshacer

  function init(){
    grid = Array.from({length:size},()=>Array(size).fill(0));
    score = 0; scoreEl.textContent = score;
    best = +localStorage.getItem('best-2048')||0; bestEl.textContent = best;
    tiles.forEach(el=>el.remove()); tiles.clear();
    addRandom(); addRandom();
    render();
    say('¡Ánimo! Llega a 2048.');
  }

  function saveHistory(){
    history.push({
      grid: grid.map(r=>r.slice()),
      score
    });
    if(history.length>20) history.shift();
  }

  function restore(){
    const last = history.pop();
    if(!last) return toastMsg('Nada que deshacer');
    grid = last.grid.map(r=>r.slice());
    score = last.score; updateScore();
    // reconstruir tiles
    tiles.forEach(el=>el.remove()); tiles.clear();
    render(true);
    say('Movimiento deshecho.');
  }

  function addRandom(){
    const empties=[];
    for(let r=0;r<size;r++) for(let c=0;c<size;c++) if(!grid[r][c]) empties.push([r,c]);
    if(!empties.length) return false;
    const [r,c]=empties[Math.floor(Math.random()*empties.length)];
    grid[r][c] = Math.random()<prob4?4:2;
    return true;
  }

  function render(skipNewAnim=false){
    // pintar/actualizar elementos .tile basados en grid
    for(let r=0;r<size;r++){
      for(let c=0;c<size;c++){
        const v = grid[r][c];
        const key = r+','+c;
        let el = tiles.get(key);
        if(v){
          if(!el){
            el = document.createElement('div');
            el.className = 'tile v'+v + (skipNewAnim?'':' new');
            el.textContent = v;
            boardEl.appendChild(el);
            tiles.set(key, el);
          }else{
            el.className = 'tile v'+v; el.textContent = v;
          }
          place(el,r,c);
        }else{
          if(el){ el.remove(); tiles.delete(key); }
        }
      }
    }
  }

  function place(el,r,c){
    const cellSize = (boardEl.clientWidth - 50)/4; // 10px gaps x 5
    const gap = 10;
    const top = 10 + r*(cellSize+gap);
    const left = 10 + c*(cellSize+gap);
    el.style.top = top+'px';
    el.style.left = left+'px';
    el.style.transform = 'scale(1)';
  }

  function slide(row){
    // compactar no-ceros
    const arr = row.filter(v=>v);
    for(let i=0;i<arr.length-1;i++){
      if(arr[i]===arr[i+1]){ arr[i]*=2; score += arr[i]; arr.splice(i+1,1); }
    }
    while(arr.length<size) arr.push(0);
    return arr;
  }

  function rotateGrid(times){
    for(let t=0;t<times;t++){
      const g = Array.from({length:size},()=>Array(size).fill(0));
      for(let r=0;r<size;r++) for(let c=0;c<size;c++) g[c][size-1-r]=grid[r][c];
      grid=g;
    }
  }

  function move(dir){
    // dir: 'left','right','up','down'
    saveHistory();
    const before = JSON.stringify(grid);
    if(dir==='right'){ grid = grid.map(r=>slide(r.slice().reverse()).reverse()); }
    if(dir==='left'){ grid = grid.map(r=>slide(r)); }
    if(dir==='up'){ rotateGrid(3); grid = grid.map(r=>slide(r)); rotateGrid(1); }
    if(dir==='down'){ rotateGrid(1); grid = grid.map(r=>slide(r)); rotateGrid(3); }

    if(JSON.stringify(grid)===before){ history.pop(); return; }

    updateScore();
    addRandom();
    animateAndRender();

    if(won()) say('¡Has llegado a 2048! Puedes seguir si quieres.');
    else if(lost()) say('Sin movimientos 😵 — pulsa "Nueva partida"');
  }

  function animateAndRender(){
    // simple re-render; tiles se re-crean por posición
    tiles.forEach((el, key)=>{ /* keep refs but will be replaced on render */ });
    render();
    localStorage.setItem('best-2048', best);
  }

  function updateScore(){
    scoreEl.textContent = score;
    if(score>best){ best=score; bestEl.textContent=best; }
  }

  function won(){
    return grid.some(r=>r.some(v=>v>=2048));
  }
  function movesAvailable(){
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      const v=grid[r][c];
      if(!v) return true;
      if(c<size-1 && v===grid[r][c+1]) return true;
      if(r<size-1 && v===grid[r+1][c]) return true;
    }
    return false;
  }
  function lost(){
    return !movesAvailable();
  }

  // ADDED: helper que vibra (si está activado) y ejecuta el movimiento
  function doMove(dir){
    if(hapticsEl?.checked && 'vibrate' in navigator){ navigator.vibrate(8); }
    move(dir);
  }

  // --- Input: teclado & táctil ---
  window.addEventListener('keydown',e=>{
    const k=e.key;
    if(['ArrowLeft','a','A','h','H'].includes(k)) doMove('left');
    else if(['ArrowRight','d','D','l','L'].includes(k)) doMove('right');
    else if(['ArrowUp','w','W','k','K'].includes(k)) doMove('up');
    else if(['ArrowDown','s','S','j','J'].includes(k)) doMove('down');
  }, {passive:true});

  // ADDED: gestos mejorados y bloqueo de scroll mientras se desliza
  let touchStartX=0,touchStartY=0;
  boardEl.addEventListener('touchstart',e=>{
    const t=e.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY;
  },{passive:true});
  boardEl.addEventListener('touchmove',e=>{
    // bloquear desplazamiento de la página durante el gesto
    e.preventDefault();
  }, {passive:false});
  boardEl.addEventListener('touchend',e=>{
    const t=e.changedTouches[0]; const dx=t.clientX - touchStartX; const dy=t.clientY - touchStartY;
    const absX=Math.abs(dx), absY=Math.abs(dy);
    const threshold = 24; // ADDED: más sensible que antes (20->24 con move bloqueo)
    if(Math.max(absX,absY)<threshold) return;
    if(absX>absY) doMove(dx>0?'right':'left'); else doMove(dy>0?'down':'up');
  });

  document.getElementById('new').onclick=init;
  document.getElementById('undo').onclick=restore;
  document.getElementById('help').onclick=()=>{
    alert('Cómo jugar:\n\n— Usa flechas o desliza para mover todas las fichas.\n— Dos fichas iguales se fusionan sumando.\n— Aparece una nueva ficha tras cada movimiento.\n— Llega a 2048 para ganar.');
  };

  // ADDED: pantalla completa
  document.getElementById('fs').onclick = ()=>{
    const el = document.documentElement;
    if(!document.fullscreenElement){
      el.requestFullscreen?.();
    }else{
      document.exitFullscreen?.();
    }
  };

  function say(text){ msgEl.textContent = text; }
  function toastMsg(t){ toast.textContent=t; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),1500); }

  // Inicializar
  window.addEventListener('load',()=>{ init(); setTimeout(()=>toast.classList.add('show'),400); setTimeout(()=>toast.classList.remove('show'),2200); });
  window.addEventListener('resize',()=>{
    // recolocar tiles en resize
    tiles.forEach((el,key)=>{
      const [r,c]=key.split(',').map(Number);
      place(el,r,c);
    });
  });
  </script>
</body>
</html>
